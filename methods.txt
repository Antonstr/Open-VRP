Thu Dec 8, 2011 (c) Marc Kuo
---------------------------------
This document is an overview of all the methods that are defined in the VRP CLOS. Reason for writing this document is that I often forget what the method name is, and/or it has been defined or not. This document needs to be updated each time a new method is defined.

The list of accessors are not shown here - refer to class-definitions.lisp for an overview.

-- util/network.lisp
node-distance (<Node> <Node>) 	    	 - returns distance
node (<Network>/<Problem> int)		 - returns Node, given ID

-- util/fleet.lisp
vehicle (<Fleet>/<Problem> int)		 - returns <Vehicle>, given ID
route-indices (<Vehicle>/<Fleet>/<Problem>)- returns the route as list of Node IDs
vehicle-with-node (<Fleet>/<Problem> int)- returns vehicle-ID which route has node-ID
total-dist (<Vehicle>/<Fleet> <Network>) - returns the total distance of route/fleet

-- util/output.lisp
print-routes (<Fleet>/<Problem>/<Algo>)	 - prints routes, given the fleet/problem/algo

-- util/draw-solution.lisp
draw-nodes (<Drawer> <Network>)		 - Plots all <Nodes> in <Drawer> canvas (use plot-nodes)
plot-solution (<Problem>/<Algo>)	 - Output .png file with plot of current/best solution
plot-nodes (<Problem>)			 - Output .png file showing only <Nodes>

-- util/fitness.lisp
fitness (<Problem>)			 - fitness function (to be specified further)

-- util/route.lisp
insert-node (<Vehicle> <Node> int)	 - inserts <Node> into the route of <Vehicle>, before i
append-node (<Vehicle> <Node>)		 - appends <Node> at end of route of <Vehicle>
remove-node-at (<Vehicle> int)		 - removes <Node> of route at i
remove-node-ID (<Vehicle>/<Problem> int) - removes <Node> with node-ID of route/solution
last-node (<Vehicle>)  			 - returns last <Node> route
closest-node (<Vehicle> <Network>)	 + returns closest <Node> to location of <Vehicle>
closest-node (<Problem> int)		 + accepts <Problem> and vehicle ID
closest-node (arg1 arg2 &optional tabu)  + optional arg tabu to exclude certain node-IDs

-- util/algo.lisp
run-algo (<Problem> <Algo>) 	 	 - runs, prints solution, sets current/best solution
	 				   slots in <Algo> and return the <Algo> object
solve-prob (<Problem> <Algo>)		 - NON-destructive wrapper for run-algo. 
solve-plot (<Problem> <Algo>)		 - solves and plots best solution

-- algo/tools.lisp
get-closest-vehicle (<Node> <Problem>)	 - returns <Vehicle> that is closest to given <Node>
get-closest-feasible-vehicle (<Node> <Problem>) - .. whilst constraints checking
optimal-insertion (<Problem> <Node>)     - Insert <Node> optimally (see: greedy-best-insertion)

-- algo/iterator.lisp
initialize (<Problem> <Algo>)  		 - initializes the solution in :current-solution
iterate (<Algo>)			 - performs one iteration, returns best-sol if finished
iterate-more (<Algo> int)		 - resume search with int iterations
generate-moves (<Algo>)			 - returns a list of all <Move>s to be considered
perform-move (<Problem> <Move>)		 - performs <move> on and returns <problem>
assess-move (<Problem> <Move>)		 - assess <Move>, returns and set in :fitness slot
select-move (<Algo> moves)		 - selects <Move> out of moves to be performed next
